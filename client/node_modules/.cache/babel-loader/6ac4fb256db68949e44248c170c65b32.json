{"ast":null,"code":"import { createElement, Component, useRef, useState, useCallback, useEffect } from 'react';\nimport invariant from 'tiny-invariant';\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nvar INSTANCE_MAP = new Map();\nvar OBSERVER_MAP = new Map();\nvar ROOT_IDS = new Map();\nvar consecutiveRootId = 0;\n/**\n * Generate a unique ID for the root element\n * @param root\n */\n\nfunction getRootId(root) {\n  if (!root) return '';\n  if (ROOT_IDS.has(root)) return ROOT_IDS.get(root);\n  consecutiveRootId += 1;\n  ROOT_IDS.set(root, consecutiveRootId.toString());\n  return ROOT_IDS.get(root) + '_';\n}\n/**\n * Monitor element, and trigger callback when element becomes inView\n * @param element {HTMLElement}\n * @param callback {Function} Called with inView\n * @param options {Object} InterSection observer options\n * @param options.threshold {Number} Number between 0 and 1, indicating how much of the element should be inView before triggering\n * @param options.root {HTMLElement}\n * @param options.rootMargin {String} The CSS margin to apply to the root element.\n */\n\n\nfunction observe(element, callback, options) {\n  if (options === void 0) {\n    options = {};\n  } // IntersectionObserver needs a threshold to trigger, so set it to 0 if it's not defined.\n  // Modify the options object, since it's used in the onChange handler.\n\n\n  if (!options.threshold) options.threshold = 0;\n  var _options = options,\n      root = _options.root,\n      rootMargin = _options.rootMargin,\n      threshold = _options.threshold; // Validate that the element is not being used in another <Observer />\n\n  !!INSTANCE_MAP.has(element) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"react-intersection-observer: Trying to observe %s, but it's already being observed by another instance.\\nMake sure the `ref` is only used by a single <Observer /> instance.\\n\\n%s\") : invariant(false) : void 0;\n  /* istanbul ignore if */\n\n  if (!element) return; // Create a unique ID for this observer instance, based on the root, root margin and threshold.\n  // An observer with the same options can be reused, so lets use this fact\n\n  var observerId = getRootId(root) + (rootMargin ? threshold.toString() + \"_\" + rootMargin : threshold.toString());\n  var observerInstance = OBSERVER_MAP.get(observerId);\n\n  if (!observerInstance) {\n    observerInstance = new IntersectionObserver(onChange, options);\n    /* istanbul ignore else  */\n\n    if (observerId) OBSERVER_MAP.set(observerId, observerInstance);\n  }\n\n  var instance = {\n    callback: callback,\n    element: element,\n    inView: false,\n    observerId: observerId,\n    observer: observerInstance,\n    // Make sure we have the thresholds value. It's undefined on a browser like Chrome 51.\n    thresholds: observerInstance.thresholds || (Array.isArray(threshold) ? threshold : [threshold])\n  };\n  INSTANCE_MAP.set(element, instance);\n  observerInstance.observe(element);\n  return instance;\n}\n/**\n * Stop observing an element. If an element is removed from the DOM or otherwise destroyed,\n * make sure to call this method.\n * @param element {Element}\n */\n\n\nfunction unobserve(element) {\n  if (!element) return;\n  var instance = INSTANCE_MAP.get(element);\n\n  if (instance) {\n    var observerId = instance.observerId,\n        observer = instance.observer;\n    var root = observer.root;\n    observer.unobserve(element); // Check if we are still observing any elements with the same threshold.\n\n    var itemsLeft = false; // Check if we still have observers configured with the same root.\n\n    var rootObserved = false;\n    /* istanbul ignore else  */\n\n    if (observerId) {\n      INSTANCE_MAP.forEach(function (item, key) {\n        if (key !== element) {\n          if (item.observerId === observerId) {\n            itemsLeft = true;\n            rootObserved = true;\n          }\n\n          if (item.observer.root === root) {\n            rootObserved = true;\n          }\n        }\n      });\n    }\n\n    if (!rootObserved && root) ROOT_IDS[\"delete\"](root);\n\n    if (observer && !itemsLeft) {\n      // No more elements to observe for threshold, disconnect observer\n      observer.disconnect();\n    } // Remove reference to element\n\n\n    INSTANCE_MAP[\"delete\"](element);\n  }\n}\n\nfunction onChange(changes) {\n  changes.forEach(function (intersection) {\n    var isIntersecting = intersection.isIntersecting,\n        intersectionRatio = intersection.intersectionRatio,\n        target = intersection.target;\n    var instance = INSTANCE_MAP.get(target); // Firefox can report a negative intersectionRatio when scrolling.\n\n    /* istanbul ignore else */\n\n    if (instance && intersectionRatio >= 0) {\n      // If threshold is an array, check if any of them intersects. This just triggers the onChange event multiple times.\n      var inView = instance.thresholds.some(function (threshold) {\n        return instance.inView ? intersectionRatio > threshold : intersectionRatio >= threshold;\n      });\n\n      if (isIntersecting !== undefined) {\n        // If isIntersecting is defined, ensure that the element is actually intersecting.\n        // Otherwise it reports a threshold of 0\n        inView = inView && isIntersecting;\n      }\n\n      instance.inView = inView;\n      instance.callback(inView, intersection);\n    }\n  });\n}\n\nfunction isPlainChildren(props) {\n  return typeof props.children !== 'function';\n}\n/**\n * Monitors scroll, and triggers the children function with updated props\n *\n <InView>\n {({inView, ref}) => (\n   <h1 ref={ref}>{`${inView}`}</h1>\n )}\n </InView>\n */\n\n\nvar InView = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(InView, _React$Component);\n\n  function InView() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n\n    _defineProperty(_assertThisInitialized(_this), \"state\", {\n      inView: false,\n      entry: undefined\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"node\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"handleNode\", function (node) {\n      if (_this.node) {\n        unobserve(_this.node);\n\n        if (!node && !_this.props.triggerOnce) {\n          _this.setState({\n            inView: false,\n            entry: undefined\n          });\n        }\n      }\n\n      _this.node = node ? node : null;\n\n      _this.observeNode();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleChange\", function (inView, entry) {\n      // Only trigger a state update if inView has changed.\n      // This prevents an unnecessary extra state update during mount, when the element stats outside the viewport\n      if (inView !== _this.state.inView || inView) {\n        _this.setState({\n          inView: inView,\n          entry: entry\n        });\n      }\n\n      if (_this.props.onChange) {\n        // If the user is actively listening for onChange, always trigger it\n        _this.props.onChange(inView, entry);\n      }\n    });\n\n    return _this;\n  }\n\n  var _proto = InView.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    !this.node ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"react-intersection-observer: No DOM node found. Make sure you forward \\\"ref\\\" to the root DOM element you want to observe.\") : invariant(false) : void 0;\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n    // If a IntersectionObserver option changed, reinit the observer\n    if (prevProps.rootMargin !== this.props.rootMargin || prevProps.root !== this.props.root || prevProps.threshold !== this.props.threshold) {\n      unobserve(this.node);\n      this.observeNode();\n    }\n\n    if (prevState.inView !== this.state.inView) {\n      if (this.state.inView && this.props.triggerOnce) {\n        unobserve(this.node);\n        this.node = null;\n      }\n    }\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    if (this.node) {\n      unobserve(this.node);\n      this.node = null;\n    }\n  };\n\n  _proto.observeNode = function observeNode() {\n    if (!this.node) return;\n    var _this$props = this.props,\n        threshold = _this$props.threshold,\n        root = _this$props.root,\n        rootMargin = _this$props.rootMargin;\n    observe(this.node, this.handleChange, {\n      threshold: threshold,\n      root: root,\n      rootMargin: rootMargin\n    });\n  };\n\n  _proto.render = function render() {\n    var _this$state = this.state,\n        inView = _this$state.inView,\n        entry = _this$state.entry;\n\n    if (!isPlainChildren(this.props)) {\n      return this.props.children({\n        inView: inView,\n        entry: entry,\n        ref: this.handleNode\n      });\n    }\n\n    var _this$props2 = this.props,\n        children = _this$props2.children,\n        as = _this$props2.as,\n        tag = _this$props2.tag,\n        triggerOnce = _this$props2.triggerOnce,\n        threshold = _this$props2.threshold,\n        root = _this$props2.root,\n        rootMargin = _this$props2.rootMargin,\n        onChange = _this$props2.onChange,\n        props = _objectWithoutPropertiesLoose(_this$props2, [\"children\", \"as\", \"tag\", \"triggerOnce\", \"threshold\", \"root\", \"rootMargin\", \"onChange\"]);\n\n    return createElement(as || tag || 'div', _extends({\n      ref: this.handleNode\n    }, props), children);\n  };\n\n  return InView;\n}(Component);\n\n_defineProperty(InView, \"displayName\", 'InView');\n\n_defineProperty(InView, \"defaultProps\", {\n  threshold: 0,\n  triggerOnce: false\n});\n/* eslint-disable react-hooks/exhaustive-deps */\n\n\nvar initialState = {\n  inView: false,\n  entry: undefined\n};\n\nfunction useInView(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var ref = useRef();\n\n  var _React$useState = useState(initialState),\n      state = _React$useState[0],\n      setState = _React$useState[1];\n\n  var setRef = useCallback(function (node) {\n    if (ref.current) {\n      unobserve(ref.current);\n    }\n\n    if (node) {\n      observe(node, function (inView, intersection) {\n        setState({\n          inView: inView,\n          entry: intersection\n        });\n\n        if (inView && options.triggerOnce) {\n          // If it should only trigger once, unobserve the element after it's inView\n          unobserve(node);\n        }\n      }, options);\n    } // Store a reference to the node, so we can unobserve it later\n\n\n    ref.current = node;\n  }, [options.threshold, options.root, options.rootMargin, options.triggerOnce]);\n  useEffect(function () {\n    if (!ref.current && state !== initialState && !options.triggerOnce) {\n      // If we don't have a ref, then reset the state (unless the hook is set to only `triggerOnce`)\n      // This ensures we correctly reflect the current state - If you aren't observing anything, then nothing is inView\n      setState(initialState);\n    }\n  });\n  return [setRef, state.inView, state.entry];\n}\n\nexport default InView;\nexport { InView, useInView };","map":{"version":3,"sources":["/Volumes/  Disco Externo/DEVS/personalProjects/portFolio/client/node_modules/react-intersection-observer/react-intersection-observer.esm.js"],"names":["createElement","Component","useRef","useState","useCallback","useEffect","invariant","_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","_extends","assign","target","i","arguments","length","source","prototype","hasOwnProperty","call","apply","_inheritsLoose","subClass","superClass","create","constructor","__proto__","_objectWithoutPropertiesLoose","excluded","sourceKeys","keys","indexOf","_assertThisInitialized","self","ReferenceError","INSTANCE_MAP","Map","OBSERVER_MAP","ROOT_IDS","consecutiveRootId","getRootId","root","has","get","set","toString","observe","element","callback","options","threshold","_options","rootMargin","process","env","NODE_ENV","observerId","observerInstance","IntersectionObserver","onChange","instance","inView","observer","thresholds","Array","isArray","unobserve","itemsLeft","rootObserved","forEach","item","disconnect","changes","intersection","isIntersecting","intersectionRatio","some","undefined","isPlainChildren","props","children","InView","_React$Component","_this","_len","args","_key","concat","entry","node","triggerOnce","setState","observeNode","state","_proto","componentDidMount","componentDidUpdate","prevProps","prevState","componentWillUnmount","_this$props","handleChange","render","_this$state","ref","handleNode","_this$props2","as","tag","initialState","useInView","_React$useState","setRef","current"],"mappings":"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","sourcesContent":["import { createElement, Component, useRef, useState, useCallback, useEffect } from 'react';\nimport invariant from 'tiny-invariant';\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nvar INSTANCE_MAP = new Map();\nvar OBSERVER_MAP = new Map();\nvar ROOT_IDS = new Map();\nvar consecutiveRootId = 0;\n/**\n * Generate a unique ID for the root element\n * @param root\n */\n\nfunction getRootId(root) {\n  if (!root) return '';\n  if (ROOT_IDS.has(root)) return ROOT_IDS.get(root);\n  consecutiveRootId += 1;\n  ROOT_IDS.set(root, consecutiveRootId.toString());\n  return ROOT_IDS.get(root) + '_';\n}\n/**\n * Monitor element, and trigger callback when element becomes inView\n * @param element {HTMLElement}\n * @param callback {Function} Called with inView\n * @param options {Object} InterSection observer options\n * @param options.threshold {Number} Number between 0 and 1, indicating how much of the element should be inView before triggering\n * @param options.root {HTMLElement}\n * @param options.rootMargin {String} The CSS margin to apply to the root element.\n */\n\n\nfunction observe(element, callback, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  // IntersectionObserver needs a threshold to trigger, so set it to 0 if it's not defined.\n  // Modify the options object, since it's used in the onChange handler.\n  if (!options.threshold) options.threshold = 0;\n  var _options = options,\n      root = _options.root,\n      rootMargin = _options.rootMargin,\n      threshold = _options.threshold; // Validate that the element is not being used in another <Observer />\n\n  !!INSTANCE_MAP.has(element) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"react-intersection-observer: Trying to observe %s, but it's already being observed by another instance.\\nMake sure the `ref` is only used by a single <Observer /> instance.\\n\\n%s\") : invariant(false) : void 0;\n  /* istanbul ignore if */\n\n  if (!element) return; // Create a unique ID for this observer instance, based on the root, root margin and threshold.\n  // An observer with the same options can be reused, so lets use this fact\n\n  var observerId = getRootId(root) + (rootMargin ? threshold.toString() + \"_\" + rootMargin : threshold.toString());\n  var observerInstance = OBSERVER_MAP.get(observerId);\n\n  if (!observerInstance) {\n    observerInstance = new IntersectionObserver(onChange, options);\n    /* istanbul ignore else  */\n\n    if (observerId) OBSERVER_MAP.set(observerId, observerInstance);\n  }\n\n  var instance = {\n    callback: callback,\n    element: element,\n    inView: false,\n    observerId: observerId,\n    observer: observerInstance,\n    // Make sure we have the thresholds value. It's undefined on a browser like Chrome 51.\n    thresholds: observerInstance.thresholds || (Array.isArray(threshold) ? threshold : [threshold])\n  };\n  INSTANCE_MAP.set(element, instance);\n  observerInstance.observe(element);\n  return instance;\n}\n/**\n * Stop observing an element. If an element is removed from the DOM or otherwise destroyed,\n * make sure to call this method.\n * @param element {Element}\n */\n\nfunction unobserve(element) {\n  if (!element) return;\n  var instance = INSTANCE_MAP.get(element);\n\n  if (instance) {\n    var observerId = instance.observerId,\n        observer = instance.observer;\n    var root = observer.root;\n    observer.unobserve(element); // Check if we are still observing any elements with the same threshold.\n\n    var itemsLeft = false; // Check if we still have observers configured with the same root.\n\n    var rootObserved = false;\n    /* istanbul ignore else  */\n\n    if (observerId) {\n      INSTANCE_MAP.forEach(function (item, key) {\n        if (key !== element) {\n          if (item.observerId === observerId) {\n            itemsLeft = true;\n            rootObserved = true;\n          }\n\n          if (item.observer.root === root) {\n            rootObserved = true;\n          }\n        }\n      });\n    }\n\n    if (!rootObserved && root) ROOT_IDS[\"delete\"](root);\n\n    if (observer && !itemsLeft) {\n      // No more elements to observe for threshold, disconnect observer\n      observer.disconnect();\n    } // Remove reference to element\n\n\n    INSTANCE_MAP[\"delete\"](element);\n  }\n}\n\nfunction onChange(changes) {\n  changes.forEach(function (intersection) {\n    var isIntersecting = intersection.isIntersecting,\n        intersectionRatio = intersection.intersectionRatio,\n        target = intersection.target;\n    var instance = INSTANCE_MAP.get(target); // Firefox can report a negative intersectionRatio when scrolling.\n\n    /* istanbul ignore else */\n\n    if (instance && intersectionRatio >= 0) {\n      // If threshold is an array, check if any of them intersects. This just triggers the onChange event multiple times.\n      var inView = instance.thresholds.some(function (threshold) {\n        return instance.inView ? intersectionRatio > threshold : intersectionRatio >= threshold;\n      });\n\n      if (isIntersecting !== undefined) {\n        // If isIntersecting is defined, ensure that the element is actually intersecting.\n        // Otherwise it reports a threshold of 0\n        inView = inView && isIntersecting;\n      }\n\n      instance.inView = inView;\n      instance.callback(inView, intersection);\n    }\n  });\n}\n\nfunction isPlainChildren(props) {\n  return typeof props.children !== 'function';\n}\n/**\n * Monitors scroll, and triggers the children function with updated props\n *\n <InView>\n {({inView, ref}) => (\n   <h1 ref={ref}>{`${inView}`}</h1>\n )}\n </InView>\n */\n\n\nvar InView = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(InView, _React$Component);\n\n  function InView() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n\n    _defineProperty(_assertThisInitialized(_this), \"state\", {\n      inView: false,\n      entry: undefined\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"node\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"handleNode\", function (node) {\n      if (_this.node) {\n        unobserve(_this.node);\n\n        if (!node && !_this.props.triggerOnce) {\n          _this.setState({\n            inView: false,\n            entry: undefined\n          });\n        }\n      }\n\n      _this.node = node ? node : null;\n\n      _this.observeNode();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleChange\", function (inView, entry) {\n      // Only trigger a state update if inView has changed.\n      // This prevents an unnecessary extra state update during mount, when the element stats outside the viewport\n      if (inView !== _this.state.inView || inView) {\n        _this.setState({\n          inView: inView,\n          entry: entry\n        });\n      }\n\n      if (_this.props.onChange) {\n        // If the user is actively listening for onChange, always trigger it\n        _this.props.onChange(inView, entry);\n      }\n    });\n\n    return _this;\n  }\n\n  var _proto = InView.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    !this.node ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"react-intersection-observer: No DOM node found. Make sure you forward \\\"ref\\\" to the root DOM element you want to observe.\") : invariant(false) : void 0;\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n    // If a IntersectionObserver option changed, reinit the observer\n    if (prevProps.rootMargin !== this.props.rootMargin || prevProps.root !== this.props.root || prevProps.threshold !== this.props.threshold) {\n      unobserve(this.node);\n      this.observeNode();\n    }\n\n    if (prevState.inView !== this.state.inView) {\n      if (this.state.inView && this.props.triggerOnce) {\n        unobserve(this.node);\n        this.node = null;\n      }\n    }\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    if (this.node) {\n      unobserve(this.node);\n      this.node = null;\n    }\n  };\n\n  _proto.observeNode = function observeNode() {\n    if (!this.node) return;\n    var _this$props = this.props,\n        threshold = _this$props.threshold,\n        root = _this$props.root,\n        rootMargin = _this$props.rootMargin;\n    observe(this.node, this.handleChange, {\n      threshold: threshold,\n      root: root,\n      rootMargin: rootMargin\n    });\n  };\n\n  _proto.render = function render() {\n    var _this$state = this.state,\n        inView = _this$state.inView,\n        entry = _this$state.entry;\n\n    if (!isPlainChildren(this.props)) {\n      return this.props.children({\n        inView: inView,\n        entry: entry,\n        ref: this.handleNode\n      });\n    }\n\n    var _this$props2 = this.props,\n        children = _this$props2.children,\n        as = _this$props2.as,\n        tag = _this$props2.tag,\n        triggerOnce = _this$props2.triggerOnce,\n        threshold = _this$props2.threshold,\n        root = _this$props2.root,\n        rootMargin = _this$props2.rootMargin,\n        onChange = _this$props2.onChange,\n        props = _objectWithoutPropertiesLoose(_this$props2, [\"children\", \"as\", \"tag\", \"triggerOnce\", \"threshold\", \"root\", \"rootMargin\", \"onChange\"]);\n\n    return createElement(as || tag || 'div', _extends({\n      ref: this.handleNode\n    }, props), children);\n  };\n\n  return InView;\n}(Component);\n\n_defineProperty(InView, \"displayName\", 'InView');\n\n_defineProperty(InView, \"defaultProps\", {\n  threshold: 0,\n  triggerOnce: false\n});\n\n/* eslint-disable react-hooks/exhaustive-deps */\nvar initialState = {\n  inView: false,\n  entry: undefined\n};\nfunction useInView(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var ref = useRef();\n\n  var _React$useState = useState(initialState),\n      state = _React$useState[0],\n      setState = _React$useState[1];\n\n  var setRef = useCallback(function (node) {\n    if (ref.current) {\n      unobserve(ref.current);\n    }\n\n    if (node) {\n      observe(node, function (inView, intersection) {\n        setState({\n          inView: inView,\n          entry: intersection\n        });\n\n        if (inView && options.triggerOnce) {\n          // If it should only trigger once, unobserve the element after it's inView\n          unobserve(node);\n        }\n      }, options);\n    } // Store a reference to the node, so we can unobserve it later\n\n\n    ref.current = node;\n  }, [options.threshold, options.root, options.rootMargin, options.triggerOnce]);\n  useEffect(function () {\n    if (!ref.current && state !== initialState && !options.triggerOnce) {\n      // If we don't have a ref, then reset the state (unless the hook is set to only `triggerOnce`)\n      // This ensures we correctly reflect the current state - If you aren't observing anything, then nothing is inView\n      setState(initialState);\n    }\n  });\n  return [setRef, state.inView, state.entry];\n}\n\nexport default InView;\nexport { InView, useInView };\n"]},"metadata":{},"sourceType":"module"}